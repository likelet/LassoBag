### Hybrid simulation data for evaluation process. Data is generated by adding different subtypes linearly during which idea from cross-validation is employed.

## =================================================================================================
## Pre-settings & Parameters
distribution_box <- c("guassian", "poisson", "binomial", "uniform", "gamma")
parameter_box <- list(
  "guassian" = list("mean" = c(-10, 10), "std"= c(0, 5)), 
  "poisson"  = list("lambda" = c(0, 20)), 
  "binomial" = list("size" = c(10, 300), "prob" = c(0, 1)), # size should be an interger; Output is also interger type
  "uniform" = list("min" = c(-20, 20), "max" = c(30, 100)),
  "gamma" = list("shape" = c(0.1, 10), "scale"= c(0.1, 5)) # shape and scale should be strictly larger than 0
  )

p <- 2000 # total predictors
n <- 4000 # total samples
partitions <- 10 # total partition numbers
realpre_num <- 6 # numbers of partitions which is the true model

dir_name <- "lassoBag_hybrid"

## =================================================================================================
## Generate feature matrix
choose_distri <- function (distribution_box, pattern="random") {
  # function to determine how distribution will be chosen from the box, default is random i.e. no preferred method of drawing data
  probs <- 0
  if (pattern == "random") { probs <- rep(1/length(distribution_box), length(distribution_box)) }
  else if (pattern == "guassian") {
    probs <- c(1, 0, 0, 0, 0)
    stopifnot( length(probs) == length(distribution_box) )
  }
  stopifnot(probs != c())
  dice <- rmultinom(1, 1, probs)
  for (i in 1:length(dice)) {
    if (dice[i] == 1) {return (distribution_box[i])}
  }
}

each_Xi <- function (n, distribution_box, parameter_box, pattern="random") {
  # return a vector of data that draw samples according to different situations
  this_distribution <- choose_distri(distribution_box, pattern)
  if (this_distribution == "guassian") {
    guassian_mean <- runif(1, parameter_box$guassian$mean[1], parameter_box$guassian$mean[2])
    guassian_std <- runif(1, parameter_box$guassian$std[1], parameter_box$guassian$std[2])
    return (list("distri_info"=list("type"=this_distribution, "para"=c(guassian_mean, guassian_std)), "distri"=rnorm(n, guassian_mean, guassian_std)))
    
  } else if (this_distribution == "poisson") {
    poisson_lambda <- runif(1, parameter_box$poisson$lambda[1], parameter_box$poisson$lambda[2])
    return (list("distri_info"=list("type"=this_distribution, "para"=c(poisson_lambda)), "distri"=rpois(n, poisson_lambda)))
    
  } else if (this_distribution == "binomial") {
    binomial_size <- sample(parameter_box$binomial$size[1]:parameter_box$binomial$size[2], 1) # size is an interger
    binomial_prob <- runif(1, parameter_box$binomial$prob[1], parameter_box$binomial$prob[2])
    return (list("distri_info"=list("type"=this_distribution, "para"=c(binomial_size, binomial_prob)), "distri"=rbinom(n, binomial_size, binomial_prob))) 
    
  } else if (this_distribution == "uniform") {
    uniform_min <- runif(1, parameter_box$uniform$min[1], parameter_box$uniform$min[2])
    uniform_max <- runif(1, parameter_box$uniform$max[1], parameter_box$uniform$max[2])
    return (list("distri_info"=list("type"=this_distribution, "para"=c(uniform_min, uniform_max)), "distri"=runif(n, uniform_min, uniform_max)))
    
  } else if (this_distribution == "gamma") {
    gamma_shape <- runif(1, parameter_box$gamma$shape[1], parameter_box$gamma$shape[2])
    gamma_scale <- runif(1, parameter_box$gamma$scale[1], parameter_box$gamma$scale[2])
    return (list("distri_info"=list("type"=this_distribution, "para"=c(gamma_shape, gamma_scale)), "distri"=rgamma(n, gamma_shape, scale = gamma_scale)))
    
  }
}

origin_X <- function (p, n, distribution_box, parameter_box) {
  # a funtion that generate a feature matrix of p columns with n samples
  # CONTROL OF THE MODULE 
  
  X <- c()
  X_type <- c()
  X_para <- c()
  for (i in 1:p) {
    col <- each_Xi(n, distribution_box, parameter_box)
    col_distri <- col$distri
    col_type <- col$distri_info$type
    col_para <- col$distri_info$para
    
    X <- cbind(X, col_distri)
    X_type <- cbind(X_type, col_type) 
    X_para <- cbind(X_para, col_para)
    
  }
  
  return (list("X"=X, "X_type"=X_type, "X_para"=X_para))

}

## =================================================================================================
## Generate lists of coefficient vectors that control the synthesis of petients' Y value

without_space <- function (vect) {
  # return continuous integers of the input in groups with sorted order
  # c(1,2,3,5) -> list(c(1,2,3), c(5))
  # c(1,3,4) -> list(c(1), c(3,4))
  
  # no empty vect is allowed 
  stopifnot(length(vect) != 0)
  
  # sorted and distinct vector
  vect <- unique(sort(vect))
  
  # pre-set
  current=list(c())
  first <- vect[[1]]
  out <- list(c(first))
  rest_vect <- tail(vect, -1)
  recent <- first
  index <- 1
  
  # check
  for (i in rest_vect) {
    if (i == (recent + 1)) {
      new_index_group <- list(c(out[[index]], i))
      out <- replace(out, index, new_index_group)
    } else {
      index <- index + 1
      new_index_group <- c(i)
      out <- append(out, new_index_group)
    }
    recent <- i
  }
  return (out)
}

coeff_order <- function (i, partitions, realpre_num) {
  # input number and return the instruction of building the order list
  # Return c(1,1,0,0,1) or c(1,0,0,1,1) or c(0,0,1,1,1)
  order <- c()
  for (m in 0:(realpre_num - 1)) {
    if ((i + m) %% partitions ==0) {
      order <- c(order, partitions)
    } else {
      order <- c(order, (i + m) %% partitions)
    }
  }
  coeff_or <- c()
  for (r in 1:partitions) {
    if (any(r == order)) {
      coeff_or <- c(coeff_or, 1)
    } else {
      coeff_or <- c(coeff_or, 0)
    }
  }
  
  return (coeff_or)
  
  # seperate with without_space function -> list(c(1), c(3,4,5))
  # lst_sep <- without_space(order)
  # # synthesis with "blank"
  # result <- c()
  # for (e in lst_sep) {
  #   if (length(result) == 0) {
  #     result <- c(result, e)
  #   } else {
  #     result <- c(result, 0, e)
  #   }
  # }
  # return(result)
}

ground_coeff <- function (p, number, partition_length, partitions=5, realpre_num=3) {
  # generates a ground coefficient vector based on the order in partation groups
  # assert parameters are in right shape
  stopifnot(number <= partitions)
  stopifnot(realpre_num < partitions)
  stopifnot(partition_length > 0 && p - partition_length * realpre_num >= 1)
  stopifnot(partition_length == as.integer(partition_length))
  stopifnot(p == as.integer(p))
  
  # instructions and zeros
  coeff_how <- coeff_order(number, partitions, realpre_num)
  zero_seps <- partitions - realpre_num
  each_zeros_length <- (p - partition_length * realpre_num) / zero_seps
  zeros_lengths <- c()
  last_length <- (p - partition_length * realpre_num) - (zero_seps - 1) * as.integer(each_zeros_length)
  
  # zero lengths except the last one
  if (zero_seps > 1) {
    for (time in 1:(zero_seps-1)) {
      zeros_lengths <- c(zeros_lengths, as.integer(each_zeros_length))
    }
  }
  # last one
  if (as.integer(each_zeros_length) != each_zeros_length) {
    zeros_lengths <- c(zeros_lengths, last_length)
  } else {
    zeros_lengths <- c(zeros_lengths, each_zeros_length)
  }

  # synthesis coefficient vector
  ground_coeff_out <- c()
  zero_pointer <- 1
  for (i in coeff_how) {
    if (i == 1) {
      stopifnot(i <= partitions)
      ground_coeff_out <- c(ground_coeff_out, each_Xi(partition_length, distribution_box, parameter_box, pattern = "guassian")$distri)
    } else if (i == 0) {
      zeros <- rep(0, zeros_lengths[zero_pointer])
      ground_coeff_out <- c(ground_coeff_out, zeros)
      zero_pointer <- zero_pointer + 1
    }
  }
  
  return (ground_coeff_out)
}

ground_coeffs <- function (p, partitions=5, realpre_num=3) {
  # Generates a matrix of ground coeff vectors 
  stopifnot(realpre_num < partitions)
  # basic info
  partition_length <- as.integer(p / partitions)
  
  # groud coefficients
  g_coeffs <- c()
  for (i in 1:partitions) {
    each_coeff <- ground_coeff(p, i, partition_length, partitions, realpre_num)
    g_coeffs <- cbind(g_coeffs, each_coeff)
  }
  
  g_coeffs <- data.frame(g_coeffs)
  return (g_coeffs)
}

must_have_same_lens <- function (lst) {
  # assert
  lens <- unique(lapply(lst, length))
  stopifnot(length(lens) == 1)
}

operate_vectors <- function (lst, funct) {
  # operating vectors correspondingly based on 2 argument function, e.g. funct="+", or ="combn"
  # return a single vector
  # assert all len of vectors are equal
  must_have_same_lens(lst)
  
  # operate
  out <- lst[[1]]
  for (i in tail(lst, -1)) {
    out <- do.call(funct, list(out, i))
  }
  return (out)
}

generate_names <- function (a, b) {
  # combine 2 item to a str
  return (paste(toString(a), toString(b), sep="_"))
}

level_coeffs <- function (ground_coeffs, level) {
  # return a matrix of coefficients that are synthesized by [n] ground coeffs (level n coefficients)
  # ground_coeffs is a dataframe
  
  # assert all len of vectors are equal
  must_have_same_lens(ground_coeffs)
  
  # index names
  len_gcofs <- length(ground_coeffs[1,])
  indexs <- combn(1:len_gcofs, level)
  names <- c()
  for (i in 1:ncol(indexs)) {
    name <- operate_vectors(indexs[,i], generate_names)
    names <- c(names, name)
  }
  
  # coeffs
  coeffs <- c()
  combinations <- combn(ground_coeffs, level)
  for (i in 1:ncol(combinations)) {
    coeff <- operate_vectors(combinations[,i], "+")
    coeffs <- cbind(coeffs, coeff)
  }
  
  # rename
  colnames(coeffs) <- names
  
  return (coeffs)
  
}

generate_coeffs <- function (p, partitions=5, realpre_num=3) {
  # CONTROL for this module that generate a the coeffs in data defined structure:  [[coeffs_1_2, coeffs_1_3..], [coeffs_1_2_3, coeffs_1_2_4...]...]
  # ground coeffients
  g_coeffs <- ground_coeffs(p, partitions, realpre_num)
  
  # hybrid
  hybrid <- list()
  for (i in 1:partitions) {
    hybrid[[i]] <- level_coeffs(g_coeffs, i)
  }
  return (hybrid)
  
}


## =================================================================================================
## Multiply to get Y

level_packs <- function (X, coeffs) {
  # X is a matrix
  # return a list of coY_packs each of which is returned by coY_packs function
  level_packs <- list()
  
  for (level in 1:length(coeffs)) {
    matrix_coeffs <- coeffs[[level]]
    matrix_Y <- X %*% matrix_coeffs # [X][coeffs]
    level_pack <- list("matrix_coeffs"=matrix_coeffs, "matrix_Y"=matrix_Y)
    level_packs[[level]] <- level_pack
  }
  
  return (level_packs)
}

## =================================================================================================
## Auto-save as files

saveRDS_all <- function (X, level_packs, dir_name="lassoBag_hybrid") {
  # open dir and change workspace
  dir_name <- paste(dir_name, Sys.time())
  dir.create(dir_name)
  setwd(dir_name)
  # write coY
  for (level in 1:length(level_packs)) {
    level_pack <- level_packs[[level]]
    name <- paste(paste("coY", "level", toString(level), sep = "_"), ".rds", sep = "")
    saveRDS(level_pack, file = name)
  }
  
  # X is not just a matrix but an object
  saveRDS(X, file = "X.rds")

}

## =================================================================================================
## BEGINNING OF GENERATION

# generating X object
X <- origin_X(p, n, distribution_box, parameter_box)

# generating coefficients 
coeffs <- generate_coeffs(p, partitions, realpre_num)

# generating coefficients-Y packs
levels_packs_lst <- level_packs(X$X, coeffs)

# save all
saveRDS_all(X, levels_packs_lst, dir_name)

## END OF GENERATION
## =================================================================================================
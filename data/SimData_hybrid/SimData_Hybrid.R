### Hybrid simulation data for evaluation process. Data is generated by adding different subtypes linearly during which idea from cross-validation is employed.


## =================================================================================================
## Pre-settings
## Parameters
distribution_box <- c("guassian", "poisson", "binomial", "uniform", "gamma")
parameter_box <- list(
  "guassian" = list("mean" = c(-10, 10), "std"= c(0, 5)), 
  "poisson"  = list("lambda" = c(0, 20)), 
  "binomial" = list("size" = c(10, 300), "prob" = c(0, 1)), # size should be an interger; Output is also interger type
  "uniform" = list("min" = c(-20, 20), "max" = c(30, 100)),
  "gamma" = list("shape" = c(0.1, 10), "scale"= c(0.1, 5)) # shape and scale should be strictly larger than 0
  )


## =================================================================================================
## Generate feature matrix
choose_distri <- function (distribution_box, pattern="random") {
  # function to determine how distribution will be chosen from the box, default is random i.e. no preferred method of drawing data
  if (pattern == "random") { probs <- rep(1/length(distribution_box), length(distribution_box)) }
  else {
    probs <- c(0.1, 0.2, 0.1, 0.2, 0.4)
    stopifnot( length(probs) == length(distribution_box) )
  }
  dice <- rmultinom(1, 1, probs)
  for (i in 1:length(dice)) {
    if (dice[i] == 1) {return (distribution_box[i])}
  }
}


each_Xi <- function (n, distribution_box, parameter_box) {
  # return a vector of data that draw samples according to different situations
  this_distribution <- choose_distri(distribution_box)
  if (this_distribution == "guassian") {
    guassian_mean <- runif(1, parameter_box$guassian$mean[1], parameter_box$guassian$mean[2])
    guassian_std <- runif(1, parameter_box$guassian$std[1], parameter_box$guassian$std[2])
    return (list("distri_info"=list("type"=this_distribution, "para"=c(guassian_mean, guassian_std)), "distri"=rnorm(n, guassian_mean, guassian_std)))
    
  } else if (this_distribution == "poisson") {
    poisson_lambda <- runif(1, parameter_box$poisson$lambda[1], parameter_box$poisson$lambda[2])
    return (list("distri_info"=list("type"=this_distribution, "para"=c(poisson_lambda)), "distri"=rpois(n, poisson_lambda)))
    
  } else if (this_distribution == "binomial") {
    binomial_size <- sample(parameter_box$binomial$size[1]:parameter_box$binomial$size[2], 1) # size is an interger
    binomial_prob <- runif(1, parameter_box$binomial$prob[1], parameter_box$binomial$prob[2])
    return (list("distri_info"=list("type"=this_distribution, "para"=c(binomial_size, binomial_prob)), "distri"=rbinom(n, binomial_size, binomial_prob))) 
    
  } else if (this_distribution == "uniform") {
    uniform_min <- runif(1, parameter_box$uniform$min[1], parameter_box$uniform$min[2])
    uniform_max <- runif(1, parameter_box$uniform$max[1], parameter_box$uniform$max[2])
    return (list("distri_info"=list("type"=this_distribution, "para"=c(uniform_min, uniform_max)), "distri"=runif(n, uniform_min, uniform_max)))
    
  } else if (this_distribution == "gamma") {
    gamma_shape <- runif(1, parameter_box$gamma$shape[1], parameter_box$gamma$shape[2])
    gamma_scale <- runif(1, parameter_box$gamma$scale[1], parameter_box$gamma$scale[2])
    return (list("distri_info"=list("type"=this_distribution, "para"=c(gamma_shape, gamma_scale)), "distri"=rgamma(n, gamma_shape, scale = gamma_scale)))
    
  }
}


origin_X <- function (p, n, distribution_box, parameter_box) {
  # a funtion that generate a feature matrix of p columns with n samples
  # CONTROL OF THE MODULE 
  X <- c()
  X_type <- c()
  X_para <- c()
  for (i in 1:p) {
    col <- each_Xi(n, distribution_box, parameter_box)
    col_distri <- col$distri
    col_type <- col$distri_info$type
    col_para <- col$distri_info$para
    
    X <- c(X, col_distri)
    X_type <- c(X_type, col_type) 
    X_para <- c(X_para, col_para)
    
  }
  
  return (list("X"=X, "X_type"=X_type, "X_para"=X_para))

}


## =================================================================================================
## Generate lists of coefficient vectors that control the synthesis of petients' Y value and 
groud_coeff <- function () {
  # generates a ground coefficient vector based on the order in partation group
  
}

groud_coeffs <- function () {
  # generates a list of ground coeff vectors 
}

multi_c_coeffs <- function () {
  # generate coefficient vectors that are synthesized by [n] ground coeffs
  
}

generate_coeffs <- function () {
  # control for this module that generate a the coeffs in data defined structure:  [[coeffs_1_2, coeffs_1_3..], [coeffs_1_2_3, coeffs_1_2_4...]...]
  # store the generated coeffs in files
}

## =================================================================================================
## Generate real Y value based on synthetic coeffs, calculate Y for each coeff and store them in seperate files.













## =================================================================================================
## END OF SIMULATION